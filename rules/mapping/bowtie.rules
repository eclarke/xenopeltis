# -*- mode: Snakemake -*-

from sunbeamlib import index_files, igv
import subprocess
import numpy

# Generate Snakemake template strings for a few commonly-used parameters below
INDICES = index_files('{genome}', Cfg['mapping']['genomes_fp'])
GENOME = str(Cfg['mapping']['genomes_fp'] / "{genome}.fasta")

rule bowtie2_all:
    # Create these three sets of files specifically:
    # * indexed sorted bam files
    # * bcf files
    # * screenshots of alignments made with IGV
    input: TARGET_MAPPING

rule bowtie2_build:
    message: "Creating bowtie2 index files for {input}"
    input: GENOME
    output: INDICES
    params:
        genome="{genome}",
        index_fp=str(Cfg['mapping']['genomes_fp'])
    shell: "cd {params.index_fp} && bowtie2-build {input} {params.genome}"

rule bowtie2_align:
    message: "Aligning {wildcards.sample} reads to genome {wildcards.genome}"
    input:
        rp = expand(str(Cfg['all']['data_fp'] / Cfg['all']['filename_fmt']), rp = ['R1','R2'], sample="{sample}"),
        indices = INDICES
    output: temp(str(MAPPING_FP/"{genome}-{sample}.sam"))
    threads: Cfg['mapping']['threads']
    params:
        genome="{genome}",
        index_fp=str(Cfg['mapping']['genomes_fp'])
    shell: "bowtie2 --threads {threads} -x {params.index_fp}/{params.genome} -1 {input.rp[0]} -2 {input.rp[1]} -S {output}"

rule samtools_view:
    message: "Converting {wildcards.genome}-{wildcards.sample} alignment from SAM to BAM format with samtools"
    input: str(MAPPING_FP/"{genome}-{sample}.sam")
    output: str(MAPPING_FP/"{genome}-{sample}.bam")
    threads: Cfg['mapping']['threads']
    shell: "samtools view -@ {threads} -bS {input} > {output}"

rule samtools_sort:
    message: "Sorting {input} with samtools"
    input: str(MAPPING_FP/"{genome}-{sample}.bam")
    output: str(MAPPING_FP/"{genome}-{sample}.sorted.bam")
    threads: Cfg['mapping']['threads']
    shell: "samtools sort -@ {threads} {input} > {output}"

def get_coverage_stats(genome_name, bamfiles, sample_names, output_fp):
    """Produce a CSV table of alignment stats for a single genome.
    
    genome_name: identifier for genome
    bamfiles: list of file paths to BAM files
    sample_names: list of idenifiers for the sample for each BAM file
    output_fp: path to CSV output file
    """
    output_rows = []
    for bamfile, sample in sorted(zip(bamfiles, sample_names)):
        # Get coverage depth at each position, even if zero across whole segment
        p = subprocess.Popen(["samtools", "depth", "-aa", bamfile], stdout=subprocess.PIPE)
        stdout, stderr = p.communicate()
        # Organize into a list of depths for each segment
        lines = str(stdout, 'ascii').splitlines()
        reader = csv.reader(lines, delimiter='\t')
        data = {}
        for row in reader:
            if not data.get(row[0]):
                data[row[0]] = []
            data[row[0]].append(int(row[2]))
        # Summarize stats for all segments present and append to output
        for segment in data.keys():
            minval     = numpy.min(data[segment])
            maxval     = numpy.max(data[segment])
            mean       = numpy.mean(data[segment])
            median     = numpy.median(data[segment])
            stddev     = numpy.std(data[segment])
            gen_cov    = len(list(filter(lambda x: x!=0, data[segment])))
            gen_length = len(data[segment])
            row = [genome_name, segment, sample, minval, maxval, mean, median, stddev, gen_cov, gen_length]
            output_rows.append(row)
    # write out stats per segment per sample
    fields = ['Genome', 'Segment', 'Sample', 'Min', 'Max', 'Mean', 'Median', 'Std Dev', 'Segment Coverage', 'Segment Length']
    with open(output_fp, 'w') as f:
        writer = csv.writer(f)
        writer.writerow(fields)
        writer.writerows(output_rows)

rule samtools_get_coverage:
    message: "Tabulating coverage stats for {wildcards.genome}"
    input: expand(str(MAPPING_FP/"{{genome}}-{sample}.sorted.bam"), sample=Samples.keys())
    output: str(MAPPING_FP/"{genome}.coverage.csv")
    run:
        get_coverage_stats(wildcards.genome, input, Samples.keys(), output[0])

rule samtools_index:
    message: "Indexing {input} with samtools"
    input: str(MAPPING_FP/"{genome}-{sample}.sorted.bam")
    output: str(MAPPING_FP/"{genome}-{sample}.sorted.bam.bai")
    shell: "samtools index {input} {output}"

rule samtools_mpileup:
    message: "Calling variants for {input.bam} with samtools and bcftools"
    input:
        bam = str(MAPPING_FP/"{genome}-{sample}.sorted.bam"),
        genome = GENOME
    output: str(MAPPING_FP/"{genome}-{sample}.raw.bcf")
    shell: "samtools mpileup -gf {input.genome} {input.bam} | bcftools call -Ob -v -c - > {output}"

# I'm creating each segment snapshot separate, but really it could be done in
# one IGV run.  Can Snakemake handle that?
rule igv_snapshot:
    message: "Create an alignment image for {wildcards.genome}-{wildcards.segment} with IGV"
    input:
        igv_fp = str(Cfg['mapping']['igv_fp']),
        genome = GENOME,
        bams=expand(str(MAPPING_FP/"{{genome}}-{sample}.sorted.bam"), sample=Samples.keys()),
        bais=expand(str(MAPPING_FP/"{{genome}}-{sample}.sorted.bam.bai"), sample=Samples.keys())
    params:
        segment="{segment}",
        igv_prefs=Cfg['mapping']['igv_prefs']
    output:
        png=str(MAPPING_FP/"{genome}-{segment}.alignment.png")
    run:
        igv.render(input.genome, sorted(input.bams), output.png, params.segment,
                   input.igv_fp, "script", params.igv_prefs)
